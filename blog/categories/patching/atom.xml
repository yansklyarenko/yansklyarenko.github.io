<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: patching | .NET, Sitecore and setup development]]></title>
  <link href="http://yansklyarenko.github.io/blog/categories/patching/atom.xml" rel="self"/>
  <link href="http://yansklyarenko.github.io/"/>
  <updated>2013-07-25T23:37:50+03:00</updated>
  <id>http://yansklyarenko.github.io/</id>
  <author>
    <name><![CDATA[Yan Sklyarenko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Revisited: Multiple Instance installations and patches]]></title>
    <link href="http://yansklyarenko.github.io/blog/2011/09/14/revisited-multiple-instance/"/>
    <updated>2011-09-14T23:00:00+03:00</updated>
    <id>http://yansklyarenko.github.io/blog/2011/09/14/revisited-multiple-instance</id>
    <content type="html"><![CDATA[<div class='post'>
<div dir="ltr" style="text-align: left;" trbidi="on">I initially <a href="http://ysdevlog.blogspot.com/2008/12/multiple-instance-installations-and.html">blogged about multiple instance installations</a> couple of years ago. The way I described it worked fine for me, but the time flies and the things has changed ever since – WiX grew up to even more solid toolset, and I also gained some knowledge. So, this post is to revisit the topic and look at it through the prism of WiX 3.6.<br />Imagine you have an application, and you’d like to be able to install several instances of it side-by-side on a single machine. The starting point is still to author the <a href="http://wix.sourceforge.net/manual-wix3/wix_xsd_instancetransforms.htm">InstanceTransforms</a> element: <pre class="brush:xml">&lt;InstanceTransforms Property="INSTANCEID"&gt;   <br />   &lt;Instance Id="I01" ProductCode="{GUIDGOES-HERE-4731-8DAA-9E843A03D482}" ProductName="My Product 01"/&gt;   <br />   &lt;Instance Id="I02" ProductCode="{GUIDGOES-HERE-4f1a-9E88-874745E9224C}" ProductName="My Product 02"/&gt;   <br />   &lt;Instance Id="I03" ProductCode="{GUIDGOES-HERE-5494-843B-BC07BBC022DB}" ProductName="My Product 03"/&gt;<br />    ...<br />&lt;/InstanceTransforms&gt;</pre>Obviously, the number of Instance elements is the number of instances supported by this installation program (plus the default one). In order to install the default instance, you should run the following command (assuming the generated MSI package is called MultiInstance.msi): <pre class="brush:csharp">msiexec /i MultiInstance.msi</pre>In order to start the installation of another instance, change the command as follows: <pre class="brush:csharp">msiexec /i MultiInstance.msi MSINEWINSTANCE=1 TRANSFORMS=":I01"</pre>The <a href="http://msdn.microsoft.com/en-us/library/aa370326.aspx">MSINEWINSTANCE</a> property set to 1 instructs msiexec to start the installation of another instance instead of default one. Note that in the above example we installing the instance I01. The Instance element results into an <a href="http://msdn.microsoft.com/en-us/library/aa369528.aspx">instance transform</a> being embedded into the MSI package, and by setting <a href="http://msdn.microsoft.com/en-us/library/aa372085.aspx">TRANSFORMS</a> property to “:I01” we instruct msiexec to apply the embedded instance transform which corresponds to the I01 instance. The TRANSFORMS property can contain other transforms (for instance, language transforms), but that’s another topic.<br/><br/>Uninstalling looks quite similar, for instance, default instance uninstallation: <pre class="brush:csharp">msiexec /x MultiInstance.msi</pre>In order to uninstall the extra instance, you should explicitly specify its ProductCode. So, for instance I01 the uninstall command line looks like this: <pre class="brush:csharp">msiexec /x {GUIDGOES-HERE-4731-8DAA-9E843A03D482}</pre>So far, so good – it is quite straight-forward. Now, let’s turn to the <a href="http://msdn.microsoft.com/en-us/library/aa367797.aspx">Windows Installer documentation about multiple instances</a> one more time. Apart from the requirement for each instance to have a unique product code and instance identifier (this is what WiX does for free with InstanceTransforms technique), it strongly recommends to keep the data isolated. For the file data, this means installing the files of each instance to a different location – the path containing instance ID as its part fits best. For the non-file data, it’s a bit more complex: the appropriate components should have different GUIDs, and again install to a different location. <br /><br/>In <a href="http://ysdevlog.blogspot.com/2008/12/multiple-instance-installations-and.html">my first attempt to approach the problem</a>, I’ve applied a workaround: generate new GUIDs for each component of new instance, embed those “component transforms” into the resulting MSI and apply along with the instance transform. Well, sounds not very efficient, but assuming a great number of components harvested automatically, this was simple enough. Fortunately, wise developers of WiX team thought this through and came up with a far more elegant solution in version 3.6.<br /><br/>Starting from <a href="http://wix.sourceforge.net/releases/3.6.1502.0/">WiX 3.6.1502.0</a>, a <a href="http://wix.sourceforge.net/manual-wix3/wix_xsd_component.htm">Component</a> element has an attribute MultiInstance of YesNo type. According to the WiX docs, “If this attribute is set to 'yes', a new Component/@Guid will be generated for each instance transform.” Fantastic! That’s what we need! Let’s see how it affects the multiple instance installations on a sample. Let’s say our installation program consists of the following components, and we’d like to be able to install this software at least 3 times: <pre class="brush:xml">&lt;Directory Id="ProductNameFolder" Name="TestName"&gt;<br />   &lt;Component Id="FileComponent" Guid="{GUIDGOES-HERE-4301-95D2-86A4C80EF5F0}"&gt;<br />      &lt;File Id="dll" Source="$(var.Source)\Some.Test.dll" KeyPath="yes" /&gt;<br />   &lt;/Component&gt;<br />   &lt;Component Id="ConfigComponent" Guid="{GUIDGOES-HERE-4c2f-BE74-CF78D2350E48}"&gt;<br />      &lt;File Id="web_config" Source="$(var.Source)\web.config" KeyPath="yes" /&gt;<br />   &lt;/Component&gt;<br />   &lt;Directory Id="EmptyFolderDir" Name="EmptyFolder"&gt;<br />      &lt;Component Id="FolderComponent" Guid="{GUIDGOES-HERE-4543-A9F8-17491670D3A6}"&gt;<br />         &lt;CreateFolder /&gt;<br />      &lt;/Component&gt;<br />   &lt;/Directory&gt;<br />   &lt;Component Id="RegistryComponent" Guid="{GUIDGOES-HERE-45e5-ABFD-07E5CC4D7BC9}"&gt;<br />      &lt;RegistryKey Id="MainRegKey" Action="createAndRemoveOnUninstall" Root="HKLM" Key="SOFTWARE\MultiInstanceTest\[ProductCode]"&gt;<br />         &lt;RegistryValue Id="MainRegValue" Name="InstanceId" Value="[INSTANCEID]" Type="string" /&gt;<br />         &lt;RegistryValue Id="InstallPathValue" Name="Location" Value="[ProductNameFolder]" Type="string" /&gt;<br />         &lt;RegistryValue Id="ProductCodeValue" Name="ProductCode" Value="[ProductCode]" Type="string" /&gt;<br />         &lt;RegistryValue Id="ProductNameValue" Name="ProductName" Value="[ProductName]" Type="string" /&gt;<br />         &lt;RegistryValue Id="ProductVersionValue" Name="ProductVersion" Value="[ProductVersion]" Type="string" /&gt;<br />      &lt;/RegistryKey&gt;<br />   &lt;/Component&gt;<br />&lt;/Directory&gt;</pre><pre class="brush:xml">&lt;InstanceTransforms Property="INSTANCEID"&gt;<br />   &lt;Instance Id="I01" ProductCode="{GUIDGOES-HERE-4731-8DAA-9E843A03D482}" ProductName="My Product 01"/&gt;<br />   &lt;Instance Id="I02" ProductCode="{GUIDGOES-HERE-4f1a-9E88-874745E9224C}" ProductName="My Product 02"/&gt;<br />&lt;/InstanceTransforms&gt;</pre>The <a href="http://msdn.microsoft.com/en-us/library/aa367797.aspx">MSDN recommendations about multiple instances</a> are followed, except for “keeping non-file data isolated”. Let’s see how it affects the install/uninstall. Run the installation of the default and I01 instance as described above. Both instances are installed to the different locations correctly:<br /><a href="http://lh4.ggpht.com/-kNoOE7Xgkpw/TnEDOVFxiDI/AAAAAAAAAc0/xDKdDlmf2-A/s1600-h/Instance00installed%25255B3%25255D.png"><img alt="Instance00installed" border="0" height="184" src="http://lh5.ggpht.com/-f-y_ymDDpsg/TnEDPFQTf5I/AAAAAAAAAc4/csVuv73w6Sc/Instance00installed_thumb%25255B1%25255D.png?imgmax=800" style="background-image: none; border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="Instance00installed" width="683" /></a><a href="http://lh6.ggpht.com/-zBD-8Nbj_JI/TnEDPmI-ZxI/AAAAAAAAAc8/0z3a4i7fM50/s1600-h/Instance00RegInstalled%25255B3%25255D.png"><img alt="Instance00RegInstalled" border="0" height="248" src="http://lh3.ggpht.com/-02O4l8thb74/TnEDQGZV0vI/AAAAAAAAAdA/K2wTQXmZC6E/Instance00RegInstalled_thumb%25255B1%25255D.png?imgmax=800" style="border-bottom-width: 0px; border-left-width: 0px; border-right-width: 0px; border-top-width: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="Instance00RegInstalled" width="1076" /></a><br /><br /><a href="http://lh3.ggpht.com/-x9bhH2JcruA/TnEDQignM9I/AAAAAAAAAdE/pKGT89S6oZ0/s1600-h/Instance01installed%25255B3%25255D.png"><img alt="Instance01installed" border="0" height="186" src="http://lh6.ggpht.com/-cvLMQCx_o6o/TnEDRvly36I/AAAAAAAAAdI/wUbopNkDXM0/Instance01installed_thumb%25255B1%25255D.png?imgmax=800" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="Instance01installed" width="680" /></a><a href="http://lh3.ggpht.com/-siDWeoSZNXk/TnEDSF2Fx4I/AAAAAAAAAdM/TlKGNa3QMkk/s1600-h/Instance01RegInstalled%25255B3%25255D.png"><img alt="Instance01RegInstalled" border="0" height="248" src="http://lh6.ggpht.com/-biKeu4p_i_E/TnEDS_RZh0I/AAAAAAAAAdQ/wx4_Pnv-wkk/Instance01RegInstalled_thumb%25255B1%25255D.png?imgmax=800" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="Instance01RegInstalled" width="1076" /></a><br /><br />Now uninstall the default instance – you’ll see that non-file data was not removed properly:<br /><br /><a href="http://lh6.ggpht.com/-0AhXVNeVdgg/TnEDTVJjUXI/AAAAAAAAAdU/cdHC2RG-Ihs/s1600-h/Instance00broken%25255B3%25255D.png"><img alt="Instance00broken" border="0" height="144" src="http://lh3.ggpht.com/-U9e8M0FckmA/TnEDT5ySS2I/AAAAAAAAAdY/YQbr_a5y3uI/Instance00broken_thumb%25255B1%25255D.png?imgmax=800" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="Instance00broken" width="679" /></a><a href="http://lh6.ggpht.com/-NzZrS2kAE3Q/TnEDURgH01I/AAAAAAAAAdc/AMxJ_8cBoBI/s1600-h/Instance00RegBroken%25255B3%25255D.png"><img alt="Instance00RegBroken" border="0" height="248" src="http://lh4.ggpht.com/-H55eKBQLubA/TnEDVKHy9TI/AAAAAAAAAdg/UVGYp9G2WAI/Instance00RegBroken_thumb%25255B1%25255D.png?imgmax=800" style="background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;" title="Instance00RegBroken" width="1076" /></a><br /><br />This is happening because the components which hold this data are considered shared by the Windows Installer, and during uninstallation of one instance it detects that there’s another one pointing to the same components and leaves those untouched. Now if you uninstall the other instance, it successfully removes both EmptyFolder and registry key, but as a result we’ll still have orphaned resources of the first instance.<br /><br />That’s the initial problem, and let’s see how elegant new WiX feature deals with it. You should only add the MultiInstance=’yes’ attribute to the components holding non-file data, and forget about the problem of orphaned resources forever. Like this: <pre class="brush:xml">&lt;Directory Id="ProductNameFolder" Name="TestName"&gt;<br />   &lt;Component Id="FileComponent" Guid="{GUIDGOES-HERE-4301-95D2-86A4C80EF5F0}"&gt;<br />      &lt;File Id="dll" Source="$(var.Source)\Some.Test.dll" KeyPath="yes" /&gt;<br />   &lt;/Component&gt;<br />   &lt;Component Id="ConfigComponent" Guid="{GUIDGOES-HERE-4c2f-BE74-CF78D2350E48}"&gt;<br />      &lt;File Id="web_config" Source="$(var.Source)\web.config" KeyPath="yes" /&gt;<br />   &lt;/Component&gt;<br />   &lt;Directory Id="EmptyFolderDir" Name="EmptyFolder"&gt;<br />      &lt;Component Id="FolderComponent" Guid="{GUIDGOES-HERE-4543-A9F8-17491670D3A6}" MultiInstance="yes"&gt;<br />         &lt;CreateFolder /&gt;<br />      &lt;/Component&gt;<br />   &lt;/Directory&gt;<br />   &lt;Component Id="RegistryComponent" Guid="{GUIDGOES-HERE-45e5-ABFD-07E5CC4D7BC9}" MultiInstance="yes"&gt;<br />      &lt;RegistryKey Id="MainRegKey" Action="createAndRemoveOnUninstall" Root="HKLM" Key="SOFTWARE\MultiInstanceTest\[ProductCode]"&gt;<br />         &lt;RegistryValue Id="MainRegValue" Name="InstanceId" Value="[INSTANCEID]" Type="string" /&gt;<br />         &lt;RegistryValue Id="InstallPathValue" Name="Location" Value="[ProductNameFolder]" Type="string" /&gt;<br />         &lt;RegistryValue Id="ProductCodeValue" Name="ProductCode" Value="[ProductCode]" Type="string" /&gt;<br />         &lt;RegistryValue Id="ProductNameValue" Name="ProductName" Value="[ProductName]" Type="string" /&gt;<br />         &lt;RegistryValue Id="ProductVersionValue" Name="ProductVersion" Value="[ProductVersion]" Type="string" /&gt;<br />      &lt;/RegistryKey&gt;<br />   &lt;/Component&gt;<br />&lt;/Directory&gt;</pre>Now check the above scenario once again: install 2 instances and uninstall them. You’ll see that both install correctly and uninstall clearly. Isn’t it GREAT?! <img alt="Smile" class="wlEmoticon wlEmoticon-smile" src="http://lh4.ggpht.com/-Q_cR2rTJMrk/TnED307vexI/AAAAAAAAAdk/KCBp9wAo2vQ/wlEmoticon-smile%25255B2%25255D.png?imgmax=800" style="border-bottom-style: none; border-left-style: none; border-right-style: none; border-top-style: none;" /><br /><br />Now, let’s turn to patching. Again, if we look back to <a href="http://ysdevlog.blogspot.com/2008/12/multiple-instance-installations-and.html">my initial post on this topic</a>, I was using an ugly method to make the patch applicable for all instances of the installed product. That method assumed opening the binary patch for read/write and rude injection into its structure. Though it worked, there’s much more elegant way of doing this. I’d like to thank <a href="http://blogs.msdn.com/b/heaths/">Heath Stewart</a> for the hint – here’s the <a href="http://www.mail-archive.com/wix-users@lists.sourceforge.net/msg27696.html">full thread on wix-users mailing list</a>.<br /><br />So, the default behavior is the following: if you author the <a href="http://wix.sourceforge.net/manual-wix3/wix_xsd_patchbaseline.htm">PatchBaseline</a> element with its default validation settings, the patch will be applicable to the default instance only. That’s because it tracks the ProductCode is the product baseline it was built against, and checks it during install time. The trick is to add a <a href="http://wix.sourceforge.net/manual-wix3/wix_xsd_validate.htm">Validate</a> child to the PatchBaseline, and instruct it not to check the ProductCode: <pre class="brush:xml">&lt;Media Id="5000" Cabinet="RTM.cab"&gt;<br />   &lt;PatchBaseline Id="RTM"&gt;<br />      &lt;Validate ProductId="no" /&gt;<br />   &lt;/PatchBaseline&gt;<br />&lt;/Media&gt;</pre>So, after you build this patch, you’ll be able to apply it to a particular instance: <pre class="brush:csharp">msiexec /i {GUIDGOES-HERE-4412-9BC2-17DAFFB00D20} PATCH=patch.msp /l*v patch.log</pre>Or to all the installed instances at once (so-called “double-click scenario”): <pre class="brush:csharp">msiexec.exe /p patch.msp /l*vx patch.log</pre>There’s still one more obvious inconvenience in the patch authoring, as for me. You have to specify the ProductCode entries twice: in the main installation sources (InstanceTransform/@ProductCode) and in the patch sources (TargetProductCode/@Id). It would be just fantastic if during patch building the WiX tools could look into the instance transforms collection of the baseline package and take the list of product codes out of there. That would omit the necessity to always specify the following section in the patch: <pre class="brush:xml">&lt;TargetProductCodes Replace="no"&gt;<br />    &lt;TargetProductCode Id="{GUIDGOES-HERE-4412-9BC2-17DAFFB00D20}" /&gt;<br />    &lt;TargetProductCode Id="{GUIDGOES-HERE-4731-8DAA-9E843A03D482}" /&gt;<br />    &lt;TargetProductCode Id="{GUIDGOES-HERE-4f1a-9E88-874745E9224C}" /&gt;<br />&lt;/TargetProductCodes&gt;</pre>As usual, WiX Toolset developers have done and keep doing fantastic job making our lives as setup developers easier! <br /><br />Feel free to leave a comment in case you have a note or a question. Feedback is welcome, as usual!</div></div>


<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>Yan Sklyarenko</div>
<div class='content'>
Roman, sorry for the indecently long delay with this reply. For some reason, I&#39;ve just mentioned this post has got more comments.<br /><br />I would suggest you looking into the shared components direction. Here&#39;s a good explanation about how it works from Heath Stewart: http://blogs.msdn.com/b/heaths/archive/2009/12/21/about-shared-components.aspx. You should try to leverage the standard facilities of Windows Installer as much as possible.<br /><br />If this is not what you&#39;re looking for and you seek for a different type of behavior, I would suggest you to store some flag in registry, and check it each time you uninstall. For instance, you can have a registry key as a shared MSI component, and tie your custom functionality to the existence of that key.</div>
</div>
<div class='comment'>
<div class='author'>Yan Sklyarenko</div>
<div class='content'>
Davide, sorry for the indecently long delay with this reply. For some reason, I&#39;ve just mentioned this post has got more comments.<br /><br />In order to achieve the unique paths for each instance, I did the following:<br /><br />1) The directory structure is like this:<br /><br />      &lt;Directory Id=&quot;TARGETDIR&quot; Name=&quot;SourceDir&quot;&gt;<br>         &lt;Directory Id=&quot;ProgramFilesFolder&quot;&gt;<br>            &lt;Directory Id=&quot;INSTALLLOCATION&quot; Name=&quot;MultiInstance36&quot;&gt;<br>               &lt;Directory Id=&quot;ProductNameFolder&quot; Name=&quot;TestName&quot;&gt;<br />....<br />     &lt;/Directory&gt;<br>            &lt;/Directory&gt;<br>         &lt;/Directory&gt;<br>      &lt;/Directory&gt;<br /><br />2) Then there&#39;s a CA, which sets the install location to the proper value:<br /><br />   &lt;SetDirectory Id=&quot;ProductNameFolder&quot; Sequence=&quot;execute&quot; Value=&quot;[INSTALLLOCATION][ProductName]&quot; /&gt;<br /><br />3) And finally, each transform sets the ProductName to the desired unique value:<br /><br />&lt;Instance Id=&quot;I01&quot; ProductCode=&quot;{YOURGIUD-GOES-HERE-8DAA-9E843A03D482}&quot; ProductName=&quot;My Product 01&quot;/&gt;<br>         &lt;Instance Id=&quot;I02&quot; ProductCode=&quot;{YOURGUID-GOES-HERE-9E88-874745E9224C}&quot; ProductName=&quot;My Product 02&quot;/&gt;<br />...<br /><br />Hope it answers your question.</div>
</div>
<div class='comment'>
<div class='author'>Yan Sklyarenko</div>
<div class='content'>
This comment has been removed by the author.</div>
</div>
<div class='comment'>
<div class='author'>Roman Himmelreich</div>
<div class='content'>
Thank you, your article is very clean and helpful.<br /><br />I am using this method to allow multiple instances for my product. I was wondering, how would you approach management of additional resources which wix/installer do not support, like Certificates. I my case every instance is has a self-signed certificate which I create on install and remove on uninstall (this is not a problem because their names are different).<br />But in addition to that, I have another self-signed certificate which is in shared use for all of them (in this case their common DataLayer component).<br /><br />I have no problem creating it and skipping creation if it exists, but how would you suggest I should build the condition under which to delete it? How do I know that the current Uninstall session is the last?<br />(Checking the registry doesn&#39;t do it, because then you&#39;d need a deferred action to return some result value for the condition...)<br /><br />Thanks in advance for any thoughts,<br />Roman.</div>
</div>
<div class='comment'>
<div class='author'>Davide Icardi</div>
<div class='content'>
Thanks for the article! I just don&#39;t understand how can you kept your files separated for each instance. How do you have organized your directory inside wix? I have tried using <br /> &lt;Directory Id=&quot;InstanceDirectory&quot; Name=&quot;[INSTANCEID]&quot;&gt; <br />but doesn&#39;t work.<br /><br />thanks<br />davide</div>
</div>
<div class='comment'>
<div class='author'>Yan Sklyarenko</div>
<div class='content'>
Published an answer on SO - let&#39;s continue the dialog there.</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Hi Yan do you have any thoughts on this?  I&#39;m trying to add the Patchbaseline element to my Patch XML.  Can you show my an example patch XML for WIX 3.6<br /><br />http://stackoverflow.com/questions/9982843/wix-3-6-patch-file-xml</div>
</div>
<div class='comment'>
<div class='author'>website designing development company chennai india</div>
<div class='content'>
I have read this post. collection of post is a nice one ..that am doing  <a href="http://www.anusuyaw3.com/web_designing.php" rel="nofollow"> website designing company chennai india</a> and <a href="http://www.anusuyaw3.com/web_designing.php" rel="nofollow"> website development company chennai india</a>. That I will inform about your post to my friends and all the best for your future posts..</div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
Wondering if you can help me out with my question posted here: http://stackoverflow.com/questions/9471790/patching-multiple-instance-installs-with-either-installshield-or-wix<br /><br />I can&#39;t get wix to put the files in the cab needed for the patch.</div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multiple instance installations and patching]]></title>
    <link href="http://yansklyarenko.github.io/blog/2008/12/30/multiple-instance-installations-and/"/>
    <updated>2008-12-30T11:00:00+02:00</updated>
    <id>http://yansklyarenko.github.io/blog/2008/12/30/multiple-instance-installations-and</id>
    <content type="html"><![CDATA[<div class='post'>
Well, this is the first message to my first weblog, and it should be outstanding by default. :-)<div><br /></div><div>Sometimes, when creating an installation program, it is necessary to support multiple instance installations of the product to one particular computer. This requirement immediately brings the complexity of the installation to the advanced level. A couple of most tricky things to look after are component rules and patching.</div><div><br /></div><div>In order to make your installation "multi-instance-aware", you should author a number of instance transforms in your source. The number of transforms is the number of instances you plan to support (except for the default one, of course). Fortunately, WiX provides very convenient way to do this:</div><div><br /></div><div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);"><span class="Apple-style-span" style="font-family: arial;">   &lt;instancetransforms property="ANY_PROPERTY"&gt;</span></span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);"><span class="Apple-style-span" style="font-family: arial;">      &lt;instance id="InstanceId1" productcode="{42A33A91-36B0-4700-A6F5-1289D22F358C}"/&gt;</span></span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);"><span class="Apple-style-span" style="font-family: arial;">      &lt;instance id="InstanceId2" productcode="{68C62C01-D064-4CF0-9239-F5D2FF36BD9A}"/&gt;</span></span></span></div><div><span class="Apple-style-span" style="color: rgb(51, 51, 255); font-size: 13px;"><span class="Apple-style-span" style="font-family: arial;">      ...</span></span></div><div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);"><span class="Apple-style-span" style="font-family: arial;">   &lt;/instancetransforms&gt;</span></span></span></div><div><br /></div><div>As always with Windows Installer, this is not the end. According to the <a href="http://msdn.microsoft.com/en-us/library/aa367797(VS.85).aspx">MSI documentation about authoring multiple instances</a>, "To keep the nonfile data of each instance isolated, the base package should collect nonfile data into sets of components for each instance". This can be done by authoring a duplicate of each component for each instance, and install conditionally. But it becomes really complex to manage when you have much more than 2 instances, let's say, 100. </div><div><br /></div><div>I chose another way. Assuming the fact that each instance should contain the same set of components, but with different GUIDs, we can generate a number of transforms, one per each instance, which change just the GUIDs of all the components. So, the algorithm is similar to this:</div><div><ul><li>copy the MSI package</li><li>use API to query and update the database with new GUIDs for each component</li><li>generate a transform between the copy and original MSI</li><li>drop the copy MSI</li><li>repeat the steps about the number of times as many instances you plan to support</li><li>embed all these transforms into the original MSI</li></ul><div>Obviously, the number of such customization transforms must be equal to the number of instance transforms and the names should be convenient to use. For instance, if you did everything correctly, you should be able to run the installation of new instance as follows:</div><div><br /></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">msiexec /i YourPackage.msi MSINEWINSTANCE=1 TRANSFORMS=:InstanceId1;:ComponentGUIDTransform1.mst ...</span></span></div><div><br /></div><div>This works like a charm in conjunction with an algorithm to detect next available instance and a bootstrapper. </div><div><br /></div><div>Now let's turn to the patching. When I browsed the internet for the info about multiple instance installs and patches, I found <a href="http://blog.deploymentengineering.com/2006/10/multiple-instance-msis-and.html">a great post of Christopher Painter</a>. As he says there, one should populate the Targets property of the patch summary info stream with product codes of all the instances, otherwise the patch detects just the default instance. That's correct, but, yes, this is not the end of the story.</div><div><br /></div><div>Let's take a look at the <a href="http://msdn.microsoft.com/en-us/library/aa370578(VS.85).aspx">patch definition and its contents</a>: "Patches contain at a minimum, two database transforms and can contain patch files that are stored in the cabinet file stream of the patch package". These two transforms contain the target product GUID and updated product GUID each. In the case of simple patching, it is just one GUID of the target product.</div><div><br /></div><div>Hence, in order to be applied to each instance, the patch must contain a pair of transforms for each instance. Unfortunately, it is not supported by WiX torch+pyro approach and we should fall back to the powerful API:</div><div><br /></div><div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   </span><span class="Apple-style-span" style="color: rgb(0, 153, 0);">// dump transform and change its properties</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   string transformFileName = GetNextValidName(transformName, nameSuffix);</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   patch.ExtractTransform(transformName, transformFileName);</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   SummaryInfo info = new SummaryInfo(transformFileName, true);</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   info.RevisionNumber = info.RevisionNumber.Replace(originalProductCode, productCode);</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   info.Persist();</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   info.Close();</span></span></div><div><br /></div></div><div>So, as you can see, we do the following (for each instance and for each of 2 transforms in default patch):</div><div><ul><li>extract transform from the patch package</li><li>change the original product code to this instance product code in summary info</li></ul><div>Afterwards, we must insert these newly created transforms into the _Storages table of the patch package:</div><div><br /></div><div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">using (View insertView = patchForWrite.OpenView("INSERT INTO `_Storages` (`Name`,`Data`) VALUES ('{0}', ?)", transformFileName))</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">{</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   using (Record record = new Record(1))</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   {</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">      record.SetStream(1, new FileStream(transformFileName, FileMode.Open));</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">      insertView.Execute(record);</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">      patchForWrite.Commit();</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   }</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">}</span></span></div><div><br /></div></div><div>And finally, we should append the product GUID of each instance to the Template property of Summary info (it is shown as Targets with Orca) and the name of each transform to the LastSavedBy property of the Summary info (it is not shown with Orca). Something like this:</div><div><br /></div><div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(0, 153, 0);">// update patch properties</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">if (!patchForWrite.SummaryInfo.Template.Contains(productCode))</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   {</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">      patchForWrite.SummaryInfo.Template += ";" + productCode;</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">   }</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">patchForWrite.SummaryInfo.LastSavedBy += ";:" + transformFileName;</span></span></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">patchForWrite.SummaryInfo.Persist();</span></span></div><div><br /></div></div><div>That's it! Afterwards, the following magic line should work correctly and patch the installed instance of your application:</div><div><br /></div><div><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="color: rgb(51, 51, 255);">msiexec /p YourPatch.msp /n {YOURGUID-0002-0000-0000-624474736554} /qb</span></span><br /></div><div><br /></div><div>Good luck deploying! I would appreciate any comments on this.</div></div></div></div></div></div>


<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>Yan Sklyarenko</div>
<div class='content'>
Hi Andy,<br /><br />Thanks for your comment!<br /><br />Well, doing this manually every time is a bad habit :) There&#39;s an algorithm to generate a deterministic sequence of GUIDs based on the initial GUID you pass in. You can be sure that if you pass the same GUID two times, the algorithm will give you identical sequences of GUIDs. You can find the sample in WiX sources, /src/wix/uuid.cs.<br /><br />When I was writing this article, I used Christoper Paniter&#39;s post I reference in it as an inspiration and starting point of my experiments. Chris said that when you build patch, you should know the ProductCode it will be applied to. However, things have probably changed ever since, and Heath Stewart pointed out how to use  to build a patch which can be applied to any instance (see in the comments above). With this in mind, I suppose you can now build unlimited number of instance transforms at runtime and stay calm about patching... but this should be tested - I doubt I can foresee all the &quot;features&quot; of this approach. And you should keep the &quot;build-time complexity&quot; vs. &quot;runtime complexity&quot; dilemma in mind.<br /><br />When you play with this to prove it works fine, I would love to hear the results back from you! :)</div>
</div>
<div class='comment'>
<div class='author'>Andy</div>
<div class='content'>
Hi Yan,<br /><br />Great article! Just so I am sure I understand, the algorithm you describe for managing instance transforms, the steps you describe are done manually as opposed to using the API, right? <br /><br />In other words, if I wanted to define 100 instances, then using your algorithm, I am pre-defining 100 instances that are captured as 100 transform files named:<br /><br />ComponentGUIDTransform1.mst<br />ComponentGUIDTransform2.mst <br /> ...<br />ComponentGUIDTransform100.mst <br /><br />Would it be possible to read the MSI into memory and then use API calls to replace all component GUIDs in the tables at runtime? The new product codes could be queried from the registry later couldn&#39;t they?<br /><br />Thanks,<br />Andy</div>
</div>
<div class='comment'>
<div class='author'>Yan Sklyarenko</div>
<div class='content'>
Hi tobias,<br /><br />&gt;&gt; So how does the patch know what to patch?<br />You apply the patch like this:<br />   msiexec /i {YOUR-GUID} PATCH=&quot;path\to\patch.msp&quot;<br />where {YOUR-GUID} is the ProductCode (instance) to patch.<br /><br />&gt;&gt; I can just use to see it works?<br />You can try this even on a sample project referenced in a WiX manual. Just make a project multi-instance (add a couple of instance transforms), and author a patch with PatchBaseline/Validate/@ProductId = &#39;no&#39;. Then install those two instances, and patch those two instances (the way shown above).<br /><br />Also, take a look at this thread: &quot;http://www.mail-archive.com/wix-users@lists.sourceforge.net/msg27915.html&quot;<br />Heath helped me a lot in understanding this technique.<br /><br />I don&#39;t have a standalone example right now - it is tightly incorporated into our main product build script. But you&#39;re welcome to ask further questions - I&#39;ll be glad to help you.</div>
</div>
<div class='comment'>
<div class='author'>tobias</div>
<div class='content'>
Hi Yan,<br />thanks for the reply and the last comment on how to ease patching further. <br />What my thought was is that a patch also contains the component GUIDS that it is going to patch, which are different for every instance if you create instances the way you described. So how does the patch know what to patch? Anyway I think I will have to give this a try before commenting further, do you have a working that I can just use to see it works?</div>
</div>
<div class='comment'>
<div class='author'>Yan Sklyarenko</div>
<div class='content'>
quirrel, thanks for your comment.<br /><br />&gt;&gt; Does it really work the way you describe?<br /><br />The Windows Installer documentation (http://msdn.microsoft.com/en-us/library/aa367797(VS.85).aspx) claims the following: &quot;To keep the nonfile data of each instance isolated, the base package should collect nonfile data into sets of components for each instance. The appropriate components should then be installed based on conditional statements that depend on the instance identifier.&quot;<br /><br />If a component contains a CreateFolder table entry, it is considered a nonfile data. For instance, if your WiX authoring is auto-generated using Heat, it is not very convenient to differentiate file-data components and nonfile-data components. I chose giving new GUID to every component - this is easy and GUIDs are for free. <br /><br />Actually, there&#39;s an easier way to create one patch for all instances of one product. Set &#39;ProductId&#39; attribute of &#39;Validate&#39; element to &#39;no&#39; and the patch you build will apply to every instance.</div>
</div>
<div class='comment'>
<div class='author'>quirrel</div>
<div class='content'>
An full, simple example is always easier than snippests, but for me it is ok this way.<br />Great post on the issue. What I am worrying is the changed component GUIDs when it comes to patching. Does it really work the way you describe?</div>
</div>
<div class='comment'>
<div class='author'>Yan Sklyarenko</div>
<div class='content'>
David, which point seems unclear to you in this post? I was trying to cover the key points in this approach I used, illustrating the most tricky parts with snippets.</div>
</div>
<div class='comment'>
<div class='author'>David Cumps</div>
<div class='content'>
Any chance you have some downloadable sample WiX project illustrating this please?</div>
</div>
<div class='comment'>
<div class='author'>Alex Shyba</div>
<div class='content'>
Hi Yan - Awesome to see you blogging! Welcome!</div>
</div>
</div>

]]></content>
  </entry>
  
</feed>
