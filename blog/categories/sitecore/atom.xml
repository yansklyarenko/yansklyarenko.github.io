<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sitecore | .NET, Sitecore and setup development]]></title>
  <link href="http://yansklyarenko.github.io/blog/categories/sitecore/atom.xml" rel="self"/>
  <link href="http://yansklyarenko.github.io/"/>
  <updated>2014-11-25T00:25:56+02:00</updated>
  <id>http://yansklyarenko.github.io/</id>
  <author>
    <name><![CDATA[Yan Sklyarenko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Back to basics: Versioned, Unversioned and Shared fields]]></title>
    <link href="http://yansklyarenko.github.io/blog/2010/09/10/back-to-basics-versioned-unversioned/"/>
    <updated>2010-09-10T02:23:00+03:00</updated>
    <id>http://yansklyarenko.github.io/blog/2010/09/10/back-to-basics-versioned-unversioned</id>
    <content type="html"><![CDATA[<div class='post'>
<p>It is well-known that each field of a template can be versioned (default option), unversioned or shared. The Template Builder UI exposes the Unversioned and Shared properties as two independent checkboxes. And thus, despite it’s a very basic Sitecore concept, it is sometimes asked <a href="http://sdn.sitecore.net/forum//ShowPost.aspx?PostID=29034">what’s the point of marking a field both shared and unversioned</a>. The answer is “a field marked both shared and unversioned is still a shared field”. Think about “shared” as a superset of “unversioned” – the field can’t be shared (between all versions of all languages) without being unversioned (between all versions of one language).</p>  <p>Let’s see how it works under the hood when the field “sharing” level is changed. Let’s create a simple template with just a single field. We’ll keep the defaults so far (versioned). Now create a content item based on this template and fill in the field. </p>  <p>Sitecore fields are stored in three different tables inside the database: VersionedFields, UnversionedFields and SharedFields. The names are quite self-explanatory. Let’s run the following SQL query:</p>  <p>&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">SELECT * FROM VersionedFields WHERE FieldId = '{GUID-GOES-HERE-…}'</font></p>  <p>As a result, one record is returned – the field information of the item we’ve just created is stored in the VersionedFields table. The similar queries for UnversionedFields and SharedFields give 0 records. </p>  <p>Now change the field to be Unversioned and run all 3 queries again – it will return 1 record for UnversionedFields table and 0 for others. Change the field to be both Shared and Unversioned and repeat the experiment – the field info now resides in SharedFields table. Now if you uncheck Unversioned and leave it just Shared, it will still show 1 record for SharedFields table and 0 for others. So, here’s the evidence!</p>  <p>NOTE: changing the field “sharing” level might result in a data loss (similar to type cast operation in C#), and Sitecore warns you about it.</p>  <p>You might think that two checkboxes are to be blamed for this confusion. Check out the hot VS extension called <a href="http://visualstudiogallery.msdn.microsoft.com/en-us/44a26c88-83a7-46f6-903c-5c59bcd3d35b/view">Sitecore Rocks</a> – a brand new tool (CTP for now) for developers working with Sitecore projects in VS 2010. It seems to look more natural in this way, isn’t it?</p>  <p><a href="http://lh5.ggpht.com/_dqWPbhO6dtA/TIlsZANnP8I/AAAAAAAAAXA/3E97dawvRnU/s1600-h/RocksDesignTemplate%5B4%5D.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="RocksDesignTemplate" border="0" alt="RocksDesignTemplate" src="http://lh6.ggpht.com/_dqWPbhO6dtA/TIlsZ1BB5aI/AAAAAAAAAXE/OHGbPYeLP2s/RocksDesignTemplate_thumb%5B2%5D.png?imgmax=800" width="644" height="178" /></a></p>  </div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XSLT: inline blocks of managed code]]></title>
    <link href="http://yansklyarenko.github.io/blog/2009/07/19/xslt-inline-blocks-of-managed-code/"/>
    <updated>2009-07-19T23:24:00+03:00</updated>
    <id>http://yansklyarenko.github.io/blog/2009/07/19/xslt-inline-blocks-of-managed-code</id>
    <content type="html"><![CDATA[<div class='post'>
<p>It’s not a secret that XSLT supports <a href="http://www.w3.org/TR/xslt11/#define-extension-functions">blocks of code</a>, written in another language, to be used inside the stylesheet. It seems to have been there from the very beginning – at least, <a href="http://www.w3.org/TR/xslt11/">XSLT 1.1</a> understands it. </p>  <p>However, Microsoft enriched this option with their own element, <a href="http://msdn.microsoft.com/en-us/library/ms256042.aspx">msxsl:script</a>. It offers pretty much the same functionality, but you can also write the code in C# or any other language of .NET platform. XSLT gurus might argue that it is superfluous stuff and it is unnecessary in 99% of cases. Well, as for me, XSLT lacks a number of useful functions in the standard library, such as ToLower/ToUpper, EndWith, etc. You never think about such low level things when programming C#, but you often have to invent a wheel trying to do the same with XSLT.</p>  <p>More details can be found in the <a href="http://msdn.microsoft.com/en-us/library/wxaw5z5e.aspx">official documentation</a>, but here is a brief extract:</p>  <ul>   <li>guess an extra prefix and let XSLT processor know about it:      <br />      <br />&lt;xsl:stylesheet version=&quot;1.0&quot;       <br />&#160; xmlns:xsl=&quot;<a href="http://www.w3.org/1999/XSL/Transform&quot;">http://www.w3.org/1999/XSL/Transform&quot;</a>       <br />&#160; xmlns:msxsl=&quot;urn:schemas-microsoft-com:xslt&quot;       <br />&#160; <strong>xmlns:ext=&quot;</strong><a href="http://my.domain.com/ext&quot;"><strong>http://my.domain.com/ext&quot;</strong></a>&gt;       <br />&#160;&#160; ...       <br />&lt;/xsl:stylesheet&gt;       <br />      <br />Also, pay attention how msxsl prefix is defined – it is required to use msxsl:script syntax.       <br /></li>    <li>code your extension function:      <br />      <br />&lt;msxsl:script language=&quot;<strong>C#&quot;</strong> implements-prefix=&quot;<strong>ext</strong>&quot;&gt;       <br />&#160;&#160; public string ToUpper(string inString)       <br />&#160;&#160; {       <br />&#160;&#160;&#160;&#160;&#160; return inString.ToUpper();       <br />&#160;&#160; }       <br />&lt;/msxsl:script&gt;       <br /></li>    <li>and finally use it:      <br />      <br />&lt;xsl:value-of select=&quot;ext:ToUpper(@Name))&quot;/&gt; </li> </ul>  <p>Obviously, it is not a good idea to write lots of code this way. It makes the XSLT stylesheet larger and a bit harder to maintain. And, according to Microsoft, you should “<a href="http://msdn.microsoft.com/en-us/library/ms256042.aspx">avoid script blocks from XSLT files, because they require loading the script engine multiple times</a>”. Actually, if you created an XSLT stylesheet to fill it with tones of .NET code, you’re definitely doing something wrong. But it seems to be good addition to small, but useful “one-line” operations.</p>  <h4>Sitecore and msxsl:script</h4>  <p>If you plan to take advantage of inline blocks of C# code in Sitecore XSL rendering, you’ll have to do one more step. By default, .NET API to handle the XSL transforms disables the possibility to use msxsl:script. It is probably done for security reason. But the web.config of your Sitecore solution contains the setting <strong>EnableXslScripts</strong>, which you can easily set to true and be happy:</p>  <p>&lt;!--&#160; ENABLE XSLT SCRIPTS    <br />&#160;&#160;&#160;&#160;&#160; Determine whether XSLT script support should be enabled.     <br />&#160;&#160;&#160;&#160;&#160; If script support is not enabled, it will be an error if the XSLT file contains script blocks.     <br />&#160;&#160;&#160;&#160;&#160; <strong>Default value: false</strong>.     <br />--&gt;     <br />&lt;setting name=&quot;EnableXslScripts&quot; value=&quot;<strong>true</strong>&quot; /&gt; </p>  <p>The performance seems to be the same for this simple code either written in msxsl:script block, or wrapped into <a href="http://sdn.sitecore.net/upload/sitecore6/61/presentation_component_cookbook_sc61_a4.pdf">XSL extension</a>. So, the choice is yours.</p>  <h4>WiX and msxsl:script</h4>  <p>The <a href="http://wix.sourceforge.net/manual-wix3/heat.htm">heat.exe</a> utility of the WiX toolset has an option to run the harvested authoring against XSLT transform. This is a checkpoint when you can mutate the output before it is done. INHO, it is the most powerful extension option of Heat, because you can do anything with the XML fragment in XSLT.</p>  <p>However, it was a bit disappointing to find out the scripts are disabled by default, and it is not customizable, and the easiest way to fix this is to patch Heat itself and prepare custom WiX build. It would be great if this option is available one day in the base, either as a command line argument, or a configuration setting.</p>  <p>That’s it. If you have some experience with this trick, knowing its pros and cons deeper, share it here. And as usual, any comments are welcome.</p>  <p>P.S. this post was written with the help of Windows Live writer :-)</p>  </div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Validating the source of TreeList]]></title>
    <link href="http://yansklyarenko.github.io/blog/2009/03/22/validating-source-of-treelist/"/>
    <updated>2009-03-22T21:18:00+02:00</updated>
    <id>http://yansklyarenko.github.io/blog/2009/03/22/validating-source-of-treelist</id>
    <content type="html"><![CDATA[<div class='post'>
Sitecore 6 validation was designed to validate the field values. Recently, I also found it useful to control the source of the complex field types, like TreeList. In this post, I'll explain this option taking the TreeList field type as an example.<div><br /></div><div>I'm skipping the validation basics here, since this topic is covered by <a href="http://alexeyrusakov.com/sitecoreblog/">Alexey Rusakov</a> in his <a href="http://alexeyrusakov.com/sitecoreblog/2008/07/02/Sitecore+6+Validation+Part+1.aspx">validation series</a>.</div><div><br /></div><div>You can define a number of parameters in the source of TreeList field type. The complete list is described in the paragraph 2.4.2 "How to Control the List of Items in a Selection Field" of the <a href="http://sdn5.sitecore.net/upload/sitecore6/datadefinitioncookbook-a4.pdf">Data Definition cookbook</a>. These parameters can filter the available and visible items in the content tree (IncludeTemplatesForSelection, ExcludeItemsForDisplay, etc.), define the tree root (DataSource), control multiple selection (AllowMultipleSelection), etc.</div><div><br /></div><div>But modifying this long list of parameters in a one-line edit field can lead to a simple typos, both in the parameters' names and values. Let's examine how this can be "solved" by introducing a source validator.</div><div><br /></div><div>The BaseValidator class, the very root of the validator hierarchy in Sitecore API, has a protected method GetField(), which returns an instance of a Field - the one we validate. Hence, the Source property is also available. We want to validate only complex source here, thus skipping if it is an ID or an item path:</div><div><br /></div><div><div>        protected override ValidatorResult Evaluate()</div><div>        {</div><div>            ValidatorResult result = ValidatorResult.Valid;</div><div><br /></div><div>            Field field = GetField();</div><div>            if (field != null)</div><div>            {</div><div>                string fieldSource = field.Source;</div><div>                if (!string.IsNullOrEmpty(fieldSource) &amp;&amp; !ID.IsID(fieldSource) </div><div>                    &amp;&amp; !fieldSource.StartsWith("/", StringComparison.InvariantCulture))</div><div>                {</div><div>                    result = EvaluateSourceParameters(fieldSource);</div><div>                }</div><div>            }</div><div><br /></div><div>            return result;</div><div>        }</div><div><br /></div></div><div>Ok, let's start the validation from just the verification if the source is "well-formed". It might happen that a certain parameter was left without a value, or a typo was introduced to the well-known name. Sitecore will never throw an error in such a case, but instead you may receive an orphaned field with nothing to choose from. Thus, the simplest validation includes these two checks, otherwise it keeps the name/value pairs for further analysis:</div><div><br /></div><div><div>        ValidatorResult EvaluateSourceParameters(string fieldSource)</div><div>        {</div><div>            SafeDictionary<string> parameters = new SafeDictionary<string>();</string></string></div><div>            string[] sourceParts = fieldSource.Split('&amp;');</div><div>            foreach (string part in sourceParts)</div><div>            {</div><div>                if (string.IsNullOrEmpty(part))</div><div>                {</div><div>                    continue;</div><div>                }</div><div>                if (!part.Contains("=") || part.EndsWith("="))</div><div>                {</div><div>                    Text = string.Format("The value is not set for source parameter '{0}'", part.TrimEnd('='));</div><div>                    return GetFailedResult(ValidatorResult.Error);</div><div>                }</div><div>                else</div><div>                {</div><div>                    string parameterName = part.Substring(0, part.IndexOf('=')).ToLower();</div><div>                    if (!sourceParameters.Contains(parameterName))</div><div>                    {</div><div>                        Text = string.Format("Unknown source parameter '{0}'", parameterName);</div><div>                        return GetFailedResult(ValidatorResult.Error);</div><div>                    }</div><div>                    else</div><div>                    {</div><div>                        string parameterValue = part.Substring(part.IndexOf('=') + 1);</div><div>                        parameters.Add(parameterName, parameterValue);</div><div>                    }</div><div>                }</div><div>            }</div><div>            return EvaluateWellFormedParameters(parameters);</div><div>        }</div><div><br /></div><div>The further validation can go deeper and verify the presence of the specified template or item. The method EvaluateWellFormedParameters in this example just iterates the name/value pairs of parameters and applies a certain validation strategy, for instance:</div><div><br /></div><div><div>        ValidatorResult EvaluateTemplates(string value, Database database)</div><div>        {</div><div>            string[] templates = value.Split(new char[] { ',' });</div><div>            foreach (string template in templates)</div><div>            {</div><div>                if (!string.IsNullOrEmpty(template) &amp;&amp; Query.SelectSingleItem(string.Format("/sitecore/templates//*[@@key='{0}']", template.ToLower()), database) == null)</div><div>                {</div><div>                    Text = string.Format("The template '{0}' doesn't exist in the '{1}' database", template, database.Name);</div><div>                    return ValidatorResult.Warning;</div><div>                }</div><div>            }</div><div>            return ValidatorResult.Valid;</div><div>        }</div><div><br /></div><div>I'm attaching the <a href="http://sites.google.com/site/yshost/Home/files/TreeListSourceValidator.cs">full code of this example</a>. </div><div><br /></div><div>There are several notes to consider:</div><div><ul><li>The DatabaseName parameter is not validated, because Sitecore takes over this. Try specifying DatabaseName=nosuchdb, and press Save</li><li>The parameter names are case-insensitive. This is because the parameters are extracted with the StringUtil.ExtractParameter() method, which ignores the case</li><li>The TreeList field type doesn't "tolower" the values of IncludeItemsForDisplay and ExcludeItemsForDisplay parameters. Hence, be sure to specify an item key instead of an item name here</li><li>The content tree filter is built out of the "ForDisplay" parameters using 'and' operation. Thus, if IncludeItemsForDisplay contain items of other templates than those specified in IncludeTemplatesForDisplay, this results in an empty tree. This can also be a point of extension of this validator's functionality</li></ul><div>Hope anyone finds this article useful. As usual, I would appreciate any comments.</div></div></div></div><div><br /></div></div>

]]></content>
  </entry>
  
</feed>
